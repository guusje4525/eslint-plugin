{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/jsx-key/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copied from https://github.com/jsx-eslint/eslint-plugin-react as this was needed for a custom check\n * @fileoverview Report missing `key` props in iterators/collection literals.\n * @author Ben Mosher\n */\n\nimport { TSESLint } from '@typescript-eslint/utils'\nimport Utils from '../utils'\n\ntype MessageIds = 'missingIterKey' | 'missingIterKeyUsePrag' | 'missingArrayKey' | 'missingArrayKeyUsePrag' | 'keyBeforeSpread' | 'nonUniqueKeys'\n\nconst myRule: TSESLint.RuleModule<MessageIds> = {\n    defaultOptions: [],\n    meta: {\n        docs: {\n            description: 'Disallow missing `key` props in iterators/collection literals',\n            recommended: 'warn',\n            url: 'https://github.com/jsx-eslint/eslint-plugin-react/tree/master/docs/rules/jsx-key.md',\n        },\n        type: 'suggestion',\n        messages: {\n            missingIterKey: 'Missing \"key\" prop for element in iterator',\n            missingIterKeyUsePrag: 'Missing \"key\" prop for element in iterator. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',\n            missingArrayKey: 'Missing \"key\" prop for element in array',\n            missingArrayKeyUsePrag: 'Missing \"key\" prop for element in array. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',\n            keyBeforeSpread: '`key` prop must be placed before any `{...spread}, to avoid conflicting with Reactâ€™s new JSX transform: https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html`',\n            nonUniqueKeys: '`key` prop must be unique',\n        },\n        schema: [{\n            type: 'object',\n            properties: {\n                checkFragmentShorthand: {\n                    type: 'boolean',\n                    default: false,\n                },\n                checkKeyMustBeforeSpread: {\n                    type: 'boolean',\n                    default: false,\n                },\n                warnOnDuplicates: {\n                    type: 'boolean',\n                    default: false,\n                },\n            },\n            additionalProperties: false,\n        }],\n    },\n    create(context: any) {\n        const options = Object.assign({}, context.options[0])\n        const checkFragmentShorthand = options.checkFragmentShorthand\n        const checkKeyMustBeforeSpread = options.checkKeyMustBeforeSpread\n        const reactPragma = Utils.pragmaUtilgetFromContext(context)\n        const fragmentPragma = 'Fragment'\n\n        function checkIteratorElement(node: any) {\n            if (node.type === 'JSXElement' && !Utils.hasProp(node.openingElement.attributes, 'key')) {\n                context.report({\n                    node,\n                    messageId: \"missingIterKey\",\n                })\n            } else if (checkFragmentShorthand && node.type === 'JSXFragment') {\n                context.report({\n                    node,\n                    messageId: \"missingIterKeyUsePrag\",\n                    data: {\n                        reactPrag: reactPragma,\n                        fragPrag: fragmentPragma,\n                    }\n                })\n            }\n        }\n\n        function getReturnStatements(node: any, args: any) {\n            const returnStatements = args || []\n            if (node.type === 'IfStatement') {\n                if (node.consequent) {\n                    getReturnStatements(node.consequent, returnStatements)\n                }\n                if (node.alternate) {\n                    getReturnStatements(node.alternate, returnStatements)\n                }\n            } else if (Array.isArray(node.body)) {\n                node.body.forEach((item: any) => {\n                    if (item.type === 'IfStatement') {\n                        getReturnStatements(item, returnStatements)\n                    }\n\n                    if (item.type === 'ReturnStatement') {\n                        returnStatements.push(item)\n                    }\n                })\n            }\n\n            return returnStatements\n        }\n\n        function isKeyAfterSpread(attributes: any) {\n            let hasFoundSpread = false\n            return attributes.some((attribute: any) => {\n                if (attribute.type === 'JSXSpreadAttribute') {\n                    hasFoundSpread = true\n                    return false\n                }\n                if (attribute.type !== 'JSXAttribute') {\n                    return false\n                }\n                return hasFoundSpread && Utils.propName(attribute) === 'key'\n            })\n        }\n\n        /**\n         * Checks if the given node is a function expression or arrow function,\n         * and checks if there is a missing key prop in return statement's arguments\n         * @param {ASTNode} node\n         */\n        function checkFunctionsBlockStatement(node: any) {\n            if (Utils.functionLikeExpression(node)) {\n                if (node.body.type === 'BlockStatement') {\n                    getReturnStatements(node.body, [])\n                        .filter((returnStatement: any) => returnStatement && returnStatement.argument)\n                        .forEach((returnStatement: any) => {\n                            checkIteratorElement(returnStatement.argument)\n                        })\n                }\n            }\n        }\n\n        /**\n         * Checks if the given node is an arrow function that has an JSX Element or JSX Fragment in its body,\n         * and the JSX is missing a key prop\n         * @param {ASTNode} node\n         */\n        function checkArrowFunctionWithJSX(node: any) {\n            const isArrFn = node && node.type === 'ArrowFunctionExpression'\n            const shouldCheckNode = (n: any) => n && (n.type === 'JSXElement' || n.type === 'JSXFragment')\n            if (isArrFn && shouldCheckNode(node.body)) {\n                checkIteratorElement(node.body)\n            }\n            if (node.body.type === 'ConditionalExpression') {\n                if (shouldCheckNode(node.body.consequent)) {\n                    checkIteratorElement(node.body.consequent)\n                }\n                if (shouldCheckNode(node.body.alternate)) {\n                    checkIteratorElement(node.body.alternate)\n                }\n            } else if (node.body.type === 'LogicalExpression' && shouldCheckNode(node.body.right)) {\n                checkIteratorElement(node.body.right)\n            }\n        }\n\n        const childrenToArraySelector = `:matches(\n      CallExpression\n        [callee.object.object.name=${reactPragma}]\n        [callee.object.property.name=Children]\n        [callee.property.name=toArray],\n      CallExpression\n        [callee.object.name=Children]\n        [callee.property.name=toArray]\n    )`.replace(/\\s/g, '')\n        let isWithinChildrenToArray = false\n\n        return {\n            [childrenToArraySelector]() {\n                isWithinChildrenToArray = true\n            },\n\n            [`${childrenToArraySelector}:exit`]() {\n                isWithinChildrenToArray = false\n            },\n\n            'ArrayExpression, JSXElement > JSXElement'(node: any) {\n                if (isWithinChildrenToArray) {\n                    return\n                }\n\n                const jsx = (node.type === 'ArrayExpression' ? node.elements : node.parent.children).filter((x: any) => x && x.type === 'JSXElement')\n                if (jsx.length === 0) {\n                    return\n                }\n\n                const map: any = {}\n                jsx.forEach((element: any) => {\n                    const attrs = element.openingElement.attributes\n                    const keys = attrs.filter((x: any) => x.name && x.name.name === 'key')\n\n                    if (keys.length === 0) {\n                        if (node.type === 'ArrayExpression') {\n                            context.report({\n                                node: element,\n                                messageId: \"missingArrayKey\"\n                            })\n                        }\n                    } else {\n                        keys.forEach((attr: any) => {\n                            const value = context.getSourceCode().getText(attr.value)\n                            if (!map[value]) { map[value] = [] }\n                            map[value].push(attr)\n\n                            if (checkKeyMustBeforeSpread && isKeyAfterSpread(attrs)) {\n                                context.report({\n                                    node: node.type === 'ArrayExpression' ? node : node.parent,\n                                    messageId: \"keyBeforeSpread\"\n                                })\n                            }\n                        })\n                    }\n                })\n            },\n\n            JSXFragment: node => {\n                if (!checkFragmentShorthand || isWithinChildrenToArray) {\n                    return\n                }\n\n                if (node.parent?.type === 'ArrayExpression') {\n                    context.report({\n                        node,\n                        messageId: \"missingArrayKeyUsePrag\",\n                        data: {\n                            reactPrag: reactPragma,\n                            fragPrag: fragmentPragma,\n                        }\n                    })\n                }\n            },\n\n            // Array.prototype.map\n            // eslint-disable-next-line no-multi-str\n            'CallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"map\"],\\\n       CallExpression[callee.type=\"OptionalMemberExpression\"][callee.property.name=\"map\"],\\\n       OptionalCallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"map\"],\\\n       OptionalCallExpression[callee.type=\"OptionalMemberExpression\"][callee.property.name=\"map\"]'(node: any) {\n                if (isWithinChildrenToArray) {\n                    return\n                }\n\n                const fn = node.arguments.length > 0 && node.arguments[0]\n                if (!fn || !Utils.functionLikeExpression(fn)) {\n                    return\n                }\n\n                checkArrowFunctionWithJSX(fn)\n\n                checkFunctionsBlockStatement(fn)\n            },\n\n            // Array.from\n            'CallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"from\"]'(node: any) {\n                if (isWithinChildrenToArray) {\n                    return\n                }\n\n                const fn = node.arguments.length > 1 && node.arguments[1]\n                if (!Utils.functionLikeExpression(fn)) {\n                    return\n                }\n\n                checkArrowFunctionWithJSX(fn)\n\n                checkFunctionsBlockStatement(fn)\n            },\n        }\n    },\n}\n\nexport default myRule\n"]}