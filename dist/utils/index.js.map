{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/utils/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Some functions copied from https://github.com/jsx-eslint/jsx-ast-utils as this was needed for a custom check\n * @fileoverview AST utility module for statically analyzing JSX\n * @author Ethan Cohen\n */\n\nimport { TSESLint, TSESTree, } from \"@typescript-eslint/utils\"\n\nexport default class Utils {\n    static JSX_ANNOTATION_REGEX = /@jsx\\s+([^\\s]+)/\n    // Does not check for reserved keywords or unicode characters\n    static JS_IDENTIFIER_REGEX = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/\n\n    static propName(prop: any = {}) {\n        if (!prop.type || prop.type !== 'JSXAttribute') {\n            throw new Error('The prop must be a JSXAttribute collected by the AST parser.')\n        }\n\n        if (prop.name.type === 'JSXNamespacedName') {\n            return `${prop.name.namespace.name}:${prop.name.name.name}`\n        }\n\n        return prop.name.name\n    }\n\n    /**\n     * Returns boolean indicating whether an prop exists on the props\n     * property of a JSX element node.\n     */\n    static hasProp(props: (TSESTree.JSXAttribute | TSESTree.JSXSpreadAttribute)[] = [], prop = '', options = { spreadStrict: true, ignoreCase: true }) {\n        const propToCheck = options.ignoreCase ? prop.toUpperCase() : prop\n\n        return props.some(attribute => {\n            // If the props contain a spread prop, then refer to strict param.\n            if (attribute.type === 'JSXSpreadAttribute') {\n                return !options.spreadStrict\n            }\n\n            const currentProp = options.ignoreCase\n                ? Utils.propName(attribute).toUpperCase()\n                : Utils.propName(attribute)\n\n            return propToCheck === currentProp\n        })\n    }\n\n    /**\n     * @param {Context} context\n     * @returns {string}\n     */\n    static pragmaUtilgetFromContext(context: Readonly<TSESLint.RuleContext<string, []>>): string {\n        let pragma: any = 'React'\n\n        const sourceCode = context.getSourceCode()\n        const pragmaNode = sourceCode.getAllComments().find((node: any) => Utils.JSX_ANNOTATION_REGEX.test(node.value))\n\n        if (pragmaNode) {\n            const matches = Utils.JSX_ANNOTATION_REGEX.exec(pragmaNode.value)\n            if (matches && matches[1]) {\n                pragma = matches[1].split('.')[0]\n            } else[\n                pragma = null\n            ]\n        }\n\n        if (!Utils.JS_IDENTIFIER_REGEX.test(pragma)) {\n            throw new Error(`React pragma ${pragma} is not a valid identifier`)\n        }\n        return pragma\n    }\n\n    static functionLikeExpression(node: any) {\n        return node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression'\n    }\n\n    static lineIsMakeAutoObserable = (node: any) => {\n        return node?.expression?.callee?.name === 'makeAutoObservable'\n    }\n\n    static lineIsThisSpIsSp = (node: any) => {\n        return !(node.type !== \"ExpressionStatement\" ||\n            node.expression.type !== \"AssignmentExpression\" ||\n            node.expression.left.type !== \"MemberExpression\" ||\n            node.expression.left.object.type !== \"ThisExpression\" ||\n            node.expression.left.property.name !== \"sp\" ||\n            node.expression.right.name !== \"sp\")\n    }\n\n    static lineMakesSpAssignment = (node: any) => {\n        return node?.expression?.type === 'AssignmentExpression' &&\n            node?.expression?.left?.type === 'MemberExpression' &&\n            node?.expression?.left?.object?.name === 'sp'\n    }\n}\n"]}